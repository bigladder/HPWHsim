#ifndef HPWHUTILS_hh
#define HPWHUTILS_hh

#include <string>

#include <cstdio>
#include <cstdlib>
#include <vector>
#include <unordered_map>

#include <courier/courier.h>

#include <nlohmann/json.hpp>

#include "hpwh-data-model.hh"

//-----------------------------------------------------------------------------
///	@brief	assign t_new to t if is_set, else assign t_default
//-----------------------------------------------------------------------------
template <typename T>
void checkFrom(T& t, const bool is_set, const T t_new, const T t_default)
{
    t = is_set ? t_new : t_default;
}

//-----------------------------------------------------------------------------
///	@brief	assign t_new to t if j contains key, else assign t_default
//-----------------------------------------------------------------------------
template <typename T>
bool checkFrom(T& t, nlohmann::json& j, std::string_view key, const T t_default)
{
    bool has_key = false;
    if (j.contains(key))
    {
        has_key = true;
        t = j[key];
    }
    else
        t = t_default;
    return has_key;
}

//-----------------------------------------------------------------------------
///	@brief	set t to t_new if has_value
//-----------------------------------------------------------------------------
template <typename T>
void checkTo(const T t, bool& is_set, T& t_new, const bool has_value = true)
{
    is_set = has_value;
    if (has_value)
    {
        t_new = t;
    }
}

//-----------------------------------------------------------------------------
///	@brief	fill metadata fields of a schema object
//-----------------------------------------------------------------------------
template <typename RSSCHEMA, typename RSTYPE>
static void generate_metadata(RSTYPE& rs, std::string_view schema_name, std::string_view schema_url)
{
    auto& metadata = rs.metadata;
    checkTo({"Big Ladder Software, LLC"}, metadata.schema_author_is_set, metadata.schema_author);
    checkTo({"California Energy Commission"}, metadata.author_is_set, metadata.author);
    checkTo({"Representation of embedded HPWH element"},
            metadata.description_is_set,
            metadata.description);
    checkTo({"Generated by HPWHsim"}, metadata.source_is_set, metadata.source);
    checkTo(std::string(RSSCHEMA::schema_version),
            metadata.schema_version_is_set,
            metadata.schema_version);
    checkTo(std::string(schema_name), metadata.schema_name_is_set, metadata.schema_name);
    checkTo(std::string(schema_url), metadata.schema_url_is_set, metadata.schema_url);

    time_t t = time(NULL);
    char time_of_creation[sizeof "2011-10-08T07:07:09Z"];

#if defined(WIN32)
    struct tm gmt;
    gmtime_s(&gmt, &t);
    strftime(time_of_creation, sizeof(time_of_creation), "%FT%TZ", &gmt);
#else
    auto ts = gmtime(&t);
    std::strftime(time_of_creation, sizeof(time_of_creation), "%FT%RZ", ts);
#endif
    checkTo(
        std::string(time_of_creation), metadata.time_of_creation_is_set, metadata.time_of_creation);

    rs.metadata_is_set = true;
}

//-----------------------------------------------------------------------------
///	@brief	transfer metadata to json dict
//-----------------------------------------------------------------------------
template <typename RSTYPE>
nlohmann::json get_metadata_as_json(const RSTYPE& rs)
{
    nlohmann::json j_metadata = {};
    auto& metadata = rs.metadata;
    if (metadata.author_is_set)
        j_metadata["author"] = rs.metadata.author;
    if (metadata.description_is_set)
        j_metadata["description"] = rs.metadata.description;
    if (metadata.schema_author_is_set)
        j_metadata["schema_author"] = rs.metadata.schema_author;
    if (metadata.schema_name_is_set)
        j_metadata["schema_name"] = rs.metadata.schema_name;
    if (metadata.schema_url_is_set)
        j_metadata["schema_url"] = rs.metadata.schema_url;
    if (metadata.schema_version_is_set)
        j_metadata["schema_version"] = rs.metadata.schema_version;
    if (metadata.source_is_set)
        j_metadata["source"] = rs.metadata.source;
    if (metadata.time_of_creation_is_set)
        j_metadata["time_of_creation"] = rs.metadata.time_of_creation;
    return j_metadata;
}

/// add fields from various schema objects to json
void add_to_json(const hpwh_data_model::hpwh_sim_input::HPWHSimInput& hsi, nlohmann::json& j);

void add_to_json(const hpwh_data_model::rsintegratedwaterheater::RSINTEGRATEDWATERHEATER& rswh,
                 nlohmann::json& j);

void add_to_json(
    const hpwh_data_model::central_water_heating_system::CentralWaterHeatingSystem& cwhs,
    nlohmann::json& j);

void add_to_json(const hpwh_data_model::rstank::RSTANK& rshs, nlohmann::json& j);

void add_to_json(
    const hpwh_data_model::rscondenserwaterheatsource::RSCONDENSERWATERHEATSOURCE& rshs,
    nlohmann::json& j);

void add_to_json(const hpwh_data_model::rsairtowaterheatpump::RSAIRTOWATERHEATPUMP& rshs,
                 nlohmann::json& j);

void add_to_json(
    const hpwh_data_model::rsresistancewaterheatsource::RSRESISTANCEWATERHEATSOURCE& rshs,
    nlohmann::json& j);

void add_to_json(const hpwh_data_model::heat_source_configuration::HeatingLogic& heating_logic,
                 nlohmann::json& j);

void add_to_json(
    const hpwh_data_model::heat_source_configuration::StateOfChargeBasedHeatingLogic& soclogic,
    nlohmann::json& j);

void add_to_json(
    const hpwh_data_model::heat_source_configuration::TemperatureBasedHeatingLogic& templogic,
    nlohmann::json& j);

#endif
